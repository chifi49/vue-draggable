{"remainingRequest":"/Users/fisigma/.nvm/versions/node/v12.16.1/lib/node_modules/@vue/cli-service-global/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/fisigma/Documents/Amazon Photos Downloads/github-projects/vue-draggable/vue-draggable.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/fisigma/Documents/Amazon Photos Downloads/github-projects/vue-draggable/vue-draggable.vue","mtime":1605181816000},{"path":"/Users/fisigma/.nvm/versions/node/v12.16.1/lib/node_modules/@vue/cli-service-global/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/fisigma/.nvm/versions/node/v12.16.1/lib/node_modules/@vue/cli-service-global/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/fisigma/.nvm/versions/node/v12.16.1/lib/node_modules/@vue/cli-service-global/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KCmltcG9ydCBWdWUgZnJvbSAndnVlJzsKZXhwb3J0IGRlZmF1bHR7CiAgICBuYW1lOid2dWUtZHJhZ2dhYmxlJywKICAgIHByb3BzOnsKICAgICAgICB0YWc6ewogICAgICAgICAgICByZXF1aXJlZDpmYWxzZSwKICAgICAgICAgICAgdHlwZTpTdHJpbmcsCiAgICAgICAgICAgIGRlZmF1bHQ6J3NwYW4nLAogICAgICAgICAgICB2YWxpZGF0b3I6ZnVuY3Rpb24odmFsdWUpewogICAgICAgICAgICAgICAgcmV0dXJuIFsnYnInLCdzY3JpcHQnLCdub3NjcmlwdCcsJ2RmbicsJ29iamVjdCddCiAgICAgICAgICAgICAgICAuaW5kZXhPZih2YWx1ZSk9PS0xCiAgICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHppbmRleDp7CiAgICAgICAgICAgIHJlcXVpcmVkOmZhbHNlLAogICAgICAgICAgICB0eXBlOk51bWJlciwKICAgICAgICAgICAgZGVmYXVsdDoxMDAgLy93aGF0IHotaW5kZXggdG8gc2V0IHdoaWxlIGRyYWdnaW5nCiAgICAgICAgfSwKICAgICAgICBheGlzOnsKICAgICAgICAgICAgcmVxdWlyZWQ6ZmFsc2UsCiAgICAgICAgICAgIHR5cGU6U3RyaW5nLAogICAgICAgICAgICBkZWZhdWx0Oid4eScKICAgICAgICB9LAogICAgICAgIG9mZnNldDp7IC8vaG93IG1hbnkgcGl4ZWxzIHRvIG1vdmUgdG8gY291bnQgaXQgYXMgZHJhZ2dpbmcKICAgICAgICAgICAgcmVxdWlyZWQ6ZmFsc2UsCiAgICAgICAgICAgIHR5cGU6TnVtYmVyLAogICAgICAgICAgICBkZWZhdWx0OjEwCiAgICAgICAgfSwKICAgICAgICAKICAgICAgICBkcmFnaGFuZGxlOnsKICAgICAgICAgICAgcmVxdWlyZWQ6ZmFsc2UsCiAgICAgICAgICAgIHR5cGU6U3RyaW5nLAogICAgICAgICAgICBkZWZhdWx0OicnIC8vYSBzZWxlY3RvciBmcm9tIHRoZSBzbG90IG9yIHRoZSB0YXJnZXQKICAgICAgICB9LAogICAgICAgIGNsb25lOnsKICAgICAgICAgICAgcmVxdWlyZWQ6ZmFsc2UsCiAgICAgICAgICAgIHR5cGU6Qm9vbGVhbiwKICAgICAgICAgICAgZGVmYXVsdDpmYWxzZQogICAgICAgIH0sCiAgICAgICAgY2xvbmVfZWxlbWVudDp7CiAgICAgICAgICAgIHJlcXVpcmVkOmZhbHNlLAogICAgICAgICAgICB0eXBlOkZ1bmN0aW9uLAogICAgICAgICAgICBkZWZhdWx0Om51bGwKICAgICAgICB9LAogICAgICAgIGNsb25lX29wYWNpdHk6ewogICAgICAgICAgICByZXF1aXJlZDpmYWxzZSwKICAgICAgICAgICAgdHlwZTpOdW1iZXIsCiAgICAgICAgICAgIGRlZmF1bHQ6MC41CiAgICAgICAgfSwKICAgICAgICBkcm9wYXJlYXM6ewogICAgICAgICAgICByZXF1aXJlZDpmYWxzZSwKICAgICAgICAgICAgdHlwZTpBcnJheSwKICAgICAgICAgICAgZGVmYXVsdDpmdW5jdGlvbigpewogICAgICAgICAgICAgICAgcmV0dXJuIFtdOwogICAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICBkcm9wcGluZ19lbGVtZW50OnsKICAgICAgICAgICAgcmVxdWlyZWQ6ZmFsc2UsCiAgICAgICAgICAgIHR5cGU6RnVuY3Rpb24sCiAgICAgICAgICAgIGRlZmF1bHQ6ZnVuY3Rpb24oKXsKICAgICAgICAgICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTsKICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5jc3NUZXh0ID0gJ2hlaWdodDoyMHB4O2JvcmRlcjpkYXNoZWQgMnB4ICNhZmFmYWYnOwogICAgICAgICAgICAgICAgZGl2LmNsYXNzTGlzdC5hZGQoJ3Z1ZS1kcm9wcGluZy1naG9zdCcpOwogICAgICAgICAgICAgICAgcmV0dXJuIGRpdjsKICAgICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgZHJvcF9naG9zdDp7IC8vZHJhZyBidXQgYWZ0ZXIgeW91IGRyb3AsIHJldHVybiB0byBpdHMgZmlyc3QgcG9zaXRpb24KICAgICAgICAgICAgcmVxdWlyZWQ6ZmFsc2UsCiAgICAgICAgICAgIHR5cGU6Qm9vbGVhbiwKICAgICAgICAgICAgZGVmYXVsdDpmYWxzZQogICAgICAgIH0sCiAgICAgICAgY29udGFpbm1lbnQ6ewogICAgICAgICAgICByZXF1aXJlZDpmYWxzZSwKICAgICAgICAgICAgdHlwZTpTdHJpbmcsCiAgICAgICAgICAgIGRlZmF1bHQ6J2JvZHknCiAgICAgICAgfSwKICAgICAgICBzb3J0YWJsZTp7CiAgICAgICAgICAgIHJlcXVpcmVkOmZhbHNlLAogICAgICAgICAgICB0eXBlOkJvb2xlYW4sCiAgICAgICAgICAgIGRlZmF1bHQ6ZmFsc2UKICAgICAgICB9CiAgICB9LAogICAgZGF0YSgpewogICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIGRvbUVsZW1lbnQ6bnVsbCwgLy93aGljaCBvbmUgdG8gZHJhZwogICAgICAgICAgICBkcmFnRWxlbWVudDpudWxsLAogICAgICAgICAgICBjbG9uZUVsZW1lbnQ6bnVsbCwKICAgICAgICAgICAgZG9tSGFuZGxlOm51bGwsIC8vZnJvbSB3aGVyZSB0byBkcmFnCiAgICAgICAgICAgIGRyb3BwaW5nRWxlbWVudDpudWxsLAogICAgICAgICAgICBjb250YWlubWVudEVsZW1lbnQ6bnVsbCwKICAgICAgICAgICAgY29udGFpbm1lbnRSZWN0Om51bGwsCiAgICAgICAgICAgIG9yaWdpbmFsX3RhcmdldDpudWxsLAogICAgICAgICAgICBvcmdpbmFsX2hhbmRsZTpudWxsLAogICAgICAgICAgICBpc0RyYWdnaW5nOmZhbHNlLAogICAgICAgICAgICBpc0Ryb3BwaW5nOmZhbHNlLAogICAgICAgICAgICBkcmFnU3RhcnRYOi0xLAogICAgICAgICAgICBkcmFnU3RhcnRZOi0xLAogICAgICAgICAgICBlbGVtZW50WDotMSwKICAgICAgICAgICAgZWxlbW5lbnRZOi0xLAogICAgICAgICAgICBlbGVtZW50RGlmZlg6MCwKICAgICAgICAgICAgZWxlbWVudERpZmZZOjAsCiAgICAgICAgICAgIGlzRHJvcHBhYmxlOmZhbHNlLCAvLyBpZiB3ZSBoYXZlIGRyb3BhcmVhcyB0aGFuIGl0IGlzIGEgZHJvcHBhYmxlCiAgICAgICAgICAgIGRyb3BwZWRfYXJlYTpudWxsLC8vdGhlIGFib3V0IHRvIGRyb3AgYXJlYQogICAgICAgICAgICBkcm9wX2FyZWFzOltdLAogICAgICAgICAgICBjc3NQb3NpdGlvbjonJywKICAgICAgICAgICAgc29ydERyb3BwaW5nRWxlbWVudF90aW1lb3V0OjAKICAgICAgICB9CiAgICB9LAogICAgY29tcHV0ZWQ6ewogICAgICAgIGlzX2RyYWdnaW5nKCl7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzRHJhZ2dpbmc7CiAgICAgICAgfSwKICAgICAgICBpc19kcm9wcGluZygpewogICAgICAgICAgICByZXR1cm4gdGhpcy5pc0Ryb3BwaW5nOwogICAgICAgIH0KICAgIH0sCiAgICBtZXRob2RzOnsKICAgICAgICBkcmFnU3RhcnRlZChldmVudCl7CiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7CiAgICAgICAgICAgIAoKICAgICAgICAgICAgaWYoIChldmVudC53aGljaCAmJiBldmVudC53aGljaD09MykgfHwgKGV2ZW50LmJ1dHRvbiAmJiBldmVudC5idXR0b249PTIpKXsvL3Nob3VsZCBub3QgZGV0ZWN0IHJpZ2h0IGNsaWNrcyBhcyBtb3VzZWRvd24gZm9yIGRyYWdnaW5nCiAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHRoaXMuaXNEcm9wcGFibGUgPSBmYWxzZTsKICAgICAgICAgICAgdGhpcy5kcm9wcGVkX2FyZWEgPSBudWxsOwoKICAgICAgICAgICAgdGhpcy5kcmFnU3RhcnRYID0gZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aD4wP2V2ZW50LnRvdWNoZXNbMF0ucGFnZVg6ZXZlbnQucGFnZVg7CiAgICAgICAgICAgIHRoaXMuZHJhZ1N0YXJ0WSA9IGV2ZW50LnRvdWNoZXMgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGg+MD9ldmVudC50b3VjaGVzWzBdLnBhZ2VZOmV2ZW50LnBhZ2VZOwogICAgICAgICAgICB0aGlzLiR2ZHJhZ2dhYmxlLmN1cnJlbnQgPSB0aGlzOwoKICAgICAgICAgICAgdmFyIGRpbSA9IHRoaXMuZHNEb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7CiAgICAgICAgICAgIHRoaXMuZWxlbWVudFggPSBkaW0ubGVmdDsKICAgICAgICAgICAgdGhpcy5lbGVtZW50WSA9IGRpbS50b3A7CiAgICAgICAgICAgIHRoaXMuZWxlbWVudERpZmZYID0gZXZlbnQucGFnZVggLSBkaW0ubGVmdDsKICAgICAgICAgICAgdGhpcy5lbGVtZW50RGlmZlkgPSBldmVudC5wYWdlWSAtIGRpbS50b3A7CgogICAgICAgICAgICB0aGlzLmNvbnRhaW5tZW50UmVjdCA9IHRoaXMuY29udGFpbm1lbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOwoKICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJyx0aGlzLmRyYWdNb3ZlKTsKICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJyx0aGlzLmRyYWdNb3ZlKTsKICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsdGhpcy5kcmFnRW5kKTsKICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLHRoaXMuZHJhZ0VuZCk7CiAgICAgICAgfSwKICAgICAgICBkcmFnTW92ZShldmVudCl7CiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7CgogICAgICAgICAgICB0aGlzLmRyb3BwZWRfYXJlYSA9IG51bGw7CiAgICAgICAgICAgIAogICAgICAgICAgICB2YXIgcGFnZVggPSBldmVudC50b3VjaGVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoPjA/ZXZlbnQudG91Y2hlc1swXS5wYWdlWDpldmVudC5wYWdlWDsKICAgICAgICAgICAgdmFyIHBhZ2VZID0gZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aD4wP2V2ZW50LnRvdWNoZXNbMF0ucGFnZVk6ZXZlbnQucGFnZVk7CiAgICAgICAgICAgIHZhciBkaWZmWCA9IHBhZ2VYIC0gdGhpcy5kcmFnU3RhcnRYOwogICAgICAgICAgICB2YXIgZGlmZlkgPSBwYWdlWSAtIHRoaXMuZHJhZ1N0YXJ0WTsKICAgICAgICAgICAgaWYodGhpcy5heGlzPT0neHknICYmIChNYXRoLmFicyhkaWZmWCk+dGhpcy5vZmZzZXQgfHwgTWF0aC5hYnMoZGlmZlkpPnRoaXMub2Zmc2V0ICkgKXsKICAgICAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7CiAgICAgICAgICAgIH1lbHNlIGlmKHRoaXMuYXhpcz09J3gnICYmIE1hdGguYWJzKGRpZmZYKT50aGlzLm9mZnNldCl7CiAgICAgICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlOwogICAgICAgICAgICB9ZWxzZSBpZih0aGlzLmF4aXM9PSd5JyAmJiBNYXRoLmFicyhkaWZmWSk+dGhpcy5vZmZzZXQpewogICAgICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZih0aGlzLmlzRHJhZ2dpbmcpewogICAgICAgICAgICAgICAgaWYodGhpcy5kcmFnRWxlbWVudD09bnVsbCl7CiAgICAgICAgICAgICAgICAgICAgLy9maXJzdCB0aW1lIHdlIGVudGVyIGhlcmUgd2hlbiBpc0RyYWdnaW5nIGJlY2FtZSB0cnVlIGZvciBmaXJzdCB0aW1lCiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXREcm9wQXJlYXMoKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmKHRoaXMuY2xvbmUgJiYgdGhpcy5kcmFnRWxlbWVudD09bnVsbCl7CiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5jbG9uZV9lbGVtZW50IT1udWxsKXsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnRWxlbWVudCA9IHRoaXMuY2xvbmVfZWxlbWVudCh7aW5zdGFuY2U6dGhpcyxlbDogdGhpcy5kc0RvbX0pOwogICAgICAgICAgICAgICAgICAgIH1lbHNlewogICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGltID0gdGhpcy5kc0RvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnRWxlbWVudCA9IHRoaXMuZHNEb20uY2xvbmVOb2RlKHRydWUpOwogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYWdFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSB0aGlzLmNsb25lX29wYWNpdHk7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ0VsZW1lbnQuc3R5bGUucG9zaXRpb249J2Fic29sdXRlJzsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnRWxlbWVudC5zdHlsZS5sZWZ0ID0gZGltLmxlZnQrJ3B4JzsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnRWxlbWVudC5zdHlsZS50b3AgPSBkaW0udG9wKydweCc7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5kcmFnRWxlbWVudCk7CgogICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2RyYWdfc3RhcnRlZCcse2luc3RhbmNlOnRoaXMsZHJhZ0VsZW1lbnQ6IHRoaXMuZHJhZ0VsZW1lbnQsIGNsb25lOiB0aGlzLmNsb25lfSkKICAgICAgICAgICAgICAgIH1lbHNlIGlmKHRoaXMuZHJhZ0VsZW1lbnQ9PW51bGwpewogICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ0VsZW1lbnQgPSB0aGlzLmRzRG9tOwogICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2RyYWdfc3RhcnRlZCcse2luc3RhbmNlOnRoaXMsZHJhZ0VsZW1lbnQ6IHRoaXMuZHJhZ0VsZW1lbnQsIGNsb25lOnRoaXMuY2xvbmV9KQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgdGhpcy5kcmFnRWxlbWVudC5zdHlsZS5wb3NpdGlvbj0nYWJzb2x1dGUnOwoKICAgICAgICAgICAgICAgIHZhciBmaW5hbFggPSBwYWdlWCAtIHRoaXMuZWxlbWVudERpZmZYOwogICAgICAgICAgICAgICAgdmFyIGZpbmFsWSA9IHBhZ2VZIC0gdGhpcy5lbGVtZW50RGlmZlk7CgogICAgICAgICAgICAgICAgLy9jaGVjayB0aGUgY29udGFpbm1lbnQsIGlmIHdlIGFyZSBpbnNpZGUgdGhlIGJvdW5kcyBvZiBwZXJtaXR0ZWQgZHJhZ2dpbmcgYXJlYQogICAgICAgICAgICAgICAgaWYoZmluYWxYPHRoaXMuY29udGFpbm1lbnRSZWN0LmxlZnQgfHwgZmluYWxYK3RoaXMuZHJhZ0VsZW1lbnQub2Zmc2V0V2lkdGg+dGhpcy5jb250YWlubWVudFJlY3QubGVmdCt0aGlzLmNvbnRhaW5tZW50UmVjdC53aWR0aAogICAgICAgICAgICB8fCBmaW5hbFk8dGhpcy5jb250YWlubWVudFJlY3QudG9wIHx8IGZpbmFsWSt0aGlzLmRyYWdFbGVtZW50Lm9mZnNldEhlaWdodD50aGlzLmNvbnRhaW5tZW50UmVjdC50b3ArdGhpcy5jb250YWlubWVudFJlY3QuaGVpZ2h0KXsKICAgICAgICAgICAgICAgIHJldHVybjsvL2RvIG5vdCBkcmFnIG91dHNpZGUgY29udGFpbm1lbnQKICAgICAgICAgICAgfQoKCiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIGlmKHRoaXMuYXhpcz09J3h5JyB8fCB0aGlzLmF4aXM9PSd4Jyl7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmFnRWxlbWVudC5zdHlsZS5sZWZ0ID0gZmluYWxYKydweCc7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZih0aGlzLmF4aXM9PSd4eScgfHwgdGhpcy5heGlzPT0neScpewogICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ0VsZW1lbnQuc3R5bGUudG9wID0gZmluYWxZKydweCc7CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnZHJhZ2dpbmcnLHtpbnN0YW5jZTp0aGlzLCBkcmFnRWxlbWVudDogdGhpcy5kcmFnRWxlbWVudCwgY2xvbmU6IHRoaXMuY2xvbmUsIGNvb3Jkczp7eDpmaW5hbFgseTpmaW5hbFl9LG5hdGl2ZUV2ZW50OiBldmVudH0pCgogICAgICAgICAgICAgICAgaWYodGhpcy5pc0Ryb3BwYWJsZSl7CiAgICAgICAgICAgICAgICAgICAgLy9maW5kIGluIHdoaWNoIGRyb3BwYWJsZSB3ZSBhcmUgY29udGFpbmVkCiAgICAgICAgICAgICAgICAgICAgLy92YXIgaXNfY29udGFpbmVkID0gZmFsc2U7CiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBkPTA7ZDx0aGlzLmRyb3BfYXJlYXMubGVuZ3RoO2QrKyl7CiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkcm9wX2FyZWEgPSB0aGlzLmRyb3BfYXJlYXNbZF07CiAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHJhZ2dhYmxlID0gewogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogZmluYWxYLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBmaW5hbFksCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5kcmFnRWxlbWVudC5vZmZzZXRXaWR0aCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5kcmFnRWxlbWVudC5vZmZzZXRIZWlnaHQKICAgICAgICAgICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuY29udGFpbnMoZHJvcF9hcmVhLGRyYWdnYWJsZSkpeyAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pc19jb250YWluZWQgPSB0cnVlOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJvcF9hcmVhLmVsLmNsYXNzTGlzdC5hZGQoJ3Z1ZS1kcm9wcGluZycpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wcGVkX2FyZWEgPSBkcm9wX2FyZWE7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHdlIGhhdmUgbm90IG1hcmtlZCBhcyBhY3RpdmUgZHJvcCBhcmVhLCBtYXJrIGl0IChzbyB3ZSBkbyBub3Qgc2VuZCBub25lIHN0b3AgZHJvcCBlbnRlciBldmVudCkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYWxzbyB3ZSBkbyBub3QgbmVlZCB0byByZWNyZWF0ZSB0aGUgZ2hvc3QgZHJvcHBpbmdfZWxlbWVudCBhZ2FpbiBhbmQgYWdhaW4sIG9uZSB0aW1lIGlzIGVub3VnaHQKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFkcm9wX2FyZWEuYWN0aXZlKXsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcm9wX2FyZWEuYWN0aXZlID0gdHJ1ZTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcm9wX2FyZWEuY3JlYXRlRHJvcHBpbmdFbGVtZW50KHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogZmluYWxYLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGZpbmFsWQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuc29ydGFibGUpewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2dldCBhbGwgZmlyc3QgZGVwdGggY2hpbGRyZW4gb2YgZHJvcF9hcmVhCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyb3BfYXJlYS5zb3J0RHJvcHBpbmdFbGVtZW50KHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGZpbmFsWCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogZmluYWxZCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdkcm9wX2VudGVyJyx7aW5zdGFuY2U6dGhpcywgZHJhZ0VsZW1lbnQ6dGhpcy5kcmFnRWxlbWVudCxjbG9uZTp0aGlzLmNsb25lLGFyZWFFbGVtZW50OiBkcm9wX2FyZWEuZWx9KTsgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wX2FyZWFzW2RdID0gZHJvcF9hcmVhOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2V7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJvcF9hcmVhLnNvcnREcm9wcGluZ0VsZW1lbnQoCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGZpbmFsWCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogZmluYWxZCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2Ryb3BwaW5nJyx7aW5zdGFuY2U6dGhpcywgZHJhZ0VsZW1lbnQ6dGhpcy5kcmFnRWxlbWVudCwgY2xvbmU6dGhpcy5jbG9uZSwgYXJlYUVsZW1lbnQ6IGRyb3BfYXJlYS5lbH0pOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZXsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaXNfY29udGFpbmVkID0gZmFsc2U7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKioKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRyb3BfYXJlYS5hY3RpdmUpewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRyb3BfYXJlYS5kcm9wcGluZ19lbGVtZW50IT1udWxsKXsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJvcF9hcmVhLmVsLnJlbW92ZUNoaWxkKGRyb3BfYXJlYS5kcm9wcGluZ19lbGVtZW50KTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJvcF9hcmVhLmRyb3BwaW5nX2VsZW1lbnQgPSBudWxsOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdkcm9wX2V4aXQnLHtpbnN0YW5jZTp0aGlzLCBkcmFnRWxlbWVudDp0aGlzLmRyYWdFbGVtZW50LCBjbG9uZTp0aGlzLmNsb25lLCBhcmVhRWxlbWVudDogZHJvcF9hcmVhLmVsfSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJvcF9hcmVhLmFjdGl2ZT0gZmFsc2U7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wX2FyZWFzW2RdID0gZHJvcF9hcmVhOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJvcF9hcmVhLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ3Z1ZS1kcm9wcGluZycpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKi8KICAgICAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICB9Ly9mb3IKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAvL2xvb3AgdGhyb3VnaCBhbGwgdGhlIGRyb3BfYXJlYXMgYW5kIGFueSBkcm9wX2FyZWEgdGhhdCBpcyBub3QgY3VycmVudGx5IGFjdGl2ZQogICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIGl0cyBhY3RpdmUgc3RhdGUgYW5kIHJlbW92ZSBhbHNvIGFueSBnaG9zdCBkcm9wcGluZyBlbGVtZW50CiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBkZD0wO2RkPHRoaXMuZHJvcF9hcmVhcy5sZW5ndGg7ZGQrKyl7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuZHJvcF9hcmVhc1tkZF0hPXRoaXMuZHJvcHBlZF9hcmVhICYmIHRoaXMuZHJvcF9hcmVhc1tkZF0uYWN0aXZlKXsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcF9hcmVhc1tkZF0uZWwuY2xhc3NMaXN0LnJlbW92ZSgndnVlLWRyb3BwaW5nJyk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3BfYXJlYXNbZGRdLmFjdGl2ZSA9IGZhbHNlOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wX2FyZWFzW2RkXS5yZW1vdmVEcm9wcGluZ0VsZW1lbnQoKTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAKCiAgICAgICAgICAgICAgICB9Ly9pZih0aGlzLmlzRHJvcHBhYmxlKQogICAgICAgICAgICAgICAgCiAgICAgICAgICAgIH0vL2lmKHRoaXMuaXNEcmFnZ2luZykKICAgICAgICB9LAogICAgICAgIGRyYWdFbmQoZXZlbnQpewogICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOwogICAgICAgICAgICAKICAgICAgICAgICAgLyoqIENIRUNLIElGIFdFIFdFUkUgRFJBR0dJTkcgdmlzIGlzRHJhZ2dpbmcsIGJlY2F1c2UgbWlnaHQgbmV2ZXIgc3RhcnRlZCAqLwogICAgICAgICAgICAvL2NvbnNvbGUubG9nKGV2ZW50KTsKICAgICAgICAgICAgaWYodGhpcy5pc0RyYWdnaW5nKXsKICAgICAgICAgICAgdmFyIGRyYWdfZWxlbWVudCA9IHRoaXMuZHJhZ0VsZW1lbnQ7CiAgICAgICAgICAgIGlmKHRoaXMuY2xvbmUgJiYgdGhpcy5pc0RyYWdnaW5nKXsgLy9iZSBzdXJlIHRvIHJlbW92ZSBjbG9uZSBlbGVtZW50IGlmIHdlIGluZGVlZCBkcmFnZ2VkCiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMuZHJhZ0VsZW1lbnQpOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIAogICAgICAgICAgICB0aGlzLmRyYWdFbGVtZW50ID0gbnVsbDsKICAgICAgICAgICAgdGhpcy5kc0RvbS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7CgogICAgICAgICAgICB2YXIgcGFnZVggPSBldmVudC50b3VjaGVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoPjA/ZXZlbnQudG91Y2hlc1swXS5wYWdlWDpldmVudC5wYWdlWDsKICAgICAgICAgICAgdmFyIHBhZ2VZID0gZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aD4wP2V2ZW50LnRvdWNoZXNbMF0ucGFnZVk6ZXZlbnQucGFnZVk7CgogICAgICAgICAgICBpZih0aGlzLmF4aXM9PSd4eScgfHwgdGhpcy5heGlzPT0neCcpewogICAgICAgICAgICAgICAgdGhpcy5kc0RvbS5zdHlsZS5sZWZ0ID0gcGFnZVggLSB0aGlzLmVsZW1lbnREaWZmWCsncHgnOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmKHRoaXMuYXhpcz09J3h5JyB8fCB0aGlzLmF4aXM9PSd5Jyl7CiAgICAgICAgICAgICAgICB0aGlzLmRzRG9tLnN0eWxlLnRvcCA9IHBhZ2VZIC0gdGhpcy5lbGVtZW50RGlmZlkrJ3B4JzsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZih0aGlzLmlzRHJvcHBhYmxlICYmIHRoaXMuZHJvcHBlZF9hcmVhIT1udWxsKXsKICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IC0xOwogICAgICAgICAgICAgICAgaWYodGhpcy5zb3J0YWJsZSl7CiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLmRyb3BwZWRfYXJlYS5kcm9wcGluZ19lbGVtZW50X2luZGV4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnZHJvcHBlZCcse2luc3RhbmNlOnRoaXMsYXJlYUVsZW1lbnQ6dGhpcy5kcm9wcGVkX2FyZWEuZWwsZHJhZ0VsZW1lbnQ6ZHJhZ19lbGVtZW50LGNsb25lOnRoaXMuY2xvbmUsc29ydGFibGU6IHRoaXMuc29ydGFibGUsIG5ld0luZGV4OiBpbmRleCB9KQogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAvL3RoaXMuZHJvcHBlZF9hcmVhLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ3Z1ZS1kcm9wcGluZycpOwoKICAgICAgICAgICAgICAgIC8vcmVtb3ZlIHRoZSBkcm9wcGluZ19lbGVtZW50CiAgICAgICAgICAgICAgICAvL3RoaXMuZHJvcHBlZF9hcmVhLmVsLnJlbW92ZUNoaWxkKHRoaXMuZHJvcHBlZF9hcmVhLmRyb3BwaW5nX2VsZW1lbnQpOwogICAgICAgICAgICAgICAgLy9pZiB3ZSBhcmUgYWN0aW5nIGFzIGEgZ2hvc3QgdGhlbiBkbyBub3QgYXBwZW5kIHRoZSBlbGVtZW50IGluIHRoZSBkcm9wcGFibGUgYXJlYSBhbmQgcmV0dXJuIGl0CiAgICAgICAgICAgICAgICAvL3RvIGl0cyBwcmV2aW91cyBwb3NpdGlvbiwgd2UgYXJlIHJlc3BvbnNpYmxlIHRvIGNyZWF0ZSB0aGUgZWxlbWVudCB3ZSB3YW50IGluIHRoZSBkcm9wcGVkIGFyZWEKICAgICAgICAgICAgICAgIGlmKCF0aGlzLmRyb3BfZ2hvc3QpewogICAgICAgICAgICAgICAgICAgLy8gYWxlcnQoJ2RvbmUnKTsKICAgICAgICAgICAgICAgICAgICBpZih0aGlzLnNvcnRhYmxlKXsKICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRyb3BwaW5nX2luZGV4ID0gdGhpcy5kcm9wcGVkX2FyZWEuZHJvcHBpbmdfZWxlbWVudF9pbmRleDsKICAgICAgICAgICAgICAgICAgICAgICAgaWYoZHJvcHBpbmdfaW5kZXg+PTAgJiYgZHJvcHBpbmdfaW5kZXg8PXRoaXMuZHJvcHBlZF9hcmVhLmNoaWxkcmVuLmxlbmd0aCl7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3BwZWRfYXJlYS5lbC5pbnNlcnRCZWZvcmUodGhpcy5kc0RvbSwgdGhpcy5kcm9wcGVkX2FyZWEuY2hpbGRyZW5bZHJvcHBpbmdfaW5kZXhdKQogICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZXsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcHBlZF9hcmVhLmVsLmFwcGVuZENoaWxkKHRoaXMuZHNEb20pOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfWVsc2V7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcHBlZF9hcmVhLmVsLmFwcGVuZENoaWxkKHRoaXMuZHNEb20pOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB0aGlzLmRzRG9tLnN0eWxlLnBvc2l0aW9uID0gdGhpcy5jc3NQb3NpdGlvbjsKICAgICAgICAgICAgICAgIH1lbHNlIGlmKHRoaXMuZHJvcF9naG9zdCl7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5kc0RvbS5zdHlsZS5wb3NpdGlvbiA9IHRoaXMuY3NzUG9zaXRpb247CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH1lbHNlIGlmKHRoaXMuaXNEcm9wcGFibGUpewogICAgICAgICAgICAgICAgLy9yZXR1cm4gdG8gcHJldmlvdXMgcG9zaXRpb24KICAgICAgICAgICAgICAgIHRoaXMuZHNEb20uc3R5bGUucG9zaXRpb24gPSB0aGlzLmNzc1Bvc2l0aW9uOwogICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7CiAgICAgICAgICAgIHRoaXMuaXNEcm9wcGFibGUgPSBmYWxzZTsKICAgICAgICAgICAgLy90aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTsKICAgICAgICAgICAgdGhpcy5kcm9wcGVkX2FyZWEgPSBudWxsOwogICAgICAgICAgICB0aGlzLiRlbWl0KCdkcmFnX2VuZGVkJyx7aW5zdGFuY2U6dGhpc30pOwogICAgICAgICAgICB0aGlzLnJlc2V0RHJvcEFyZWFzKCk7CiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsdGhpcy5kcmFnTW92ZSk7CiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLHRoaXMuZHJhZ0VuZCk7CiAgICAgICAgfSwKICAgICAgICBzZXR1cEV2ZW50SGFuZGxlcnMoKXsKICAgICAgICAgICAgdGhpcy5kc0RvbS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLHRoaXMuZHJhZ1N0YXJ0ZWQpCiAgICAgICAgICAgIHRoaXMuZHNEb20uYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsdGhpcy5kcmFnU3RhcnRlZCk7CiAgICAgICAgICAgIHRoaXMuZHNEb20uYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywoZXZlbnQpPT57CiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOwogICAgICAgICAgICB9ICkKICAgICAgICB9LAogICAgICAgIGdldElkKCl7CiAgICAgICAgICAgIHZhciBkID0gbmV3IERhdGUoKTsKICAgICAgICAgICAgcmV0dXJuICd2ZHJhZ2dhYmxlLScrZC5nZXRNaWxsaXNlb25kcygpOwogICAgICAgIH0sCiAgICAgICAgcmVzZXREcm9wQXJlYXMoKXsKICAgICAgICAgICAgCiAgICAgICAgICAgIGZvcih2YXIgZD0wO2Q8dGhpcy5kcm9wX2FyZWFzLmxlbmd0aDtkKyspewogICAgICAgICAgICAgICAgdGhpcy5kcm9wX2FyZWFzW2RdLmVsLmNsYXNzTGlzdC5yZW1vdmUoJ3Z1ZS1kcm9wcGluZycpOwogICAgICAgICAgICAgICAgdGhpcy5kcm9wX2FyZWFzW2RdLmFjdGl2ZSA9IGZhbHNlOwogICAgICAgICAgICAgICAgLy9lYW4gZXhvIGRyb3BwaW5nIGVsZW1lbnQgZGltaW91cmdpbWVubywga2F0ZXN0cmVwc2UgdG8KICAgICAgICAgICAgICAgIGlmKHRoaXMuZHJvcF9hcmVhc1tkXS5kcm9wcGluZ19lbGVtZW50IT1udWxsKXsKICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3BfYXJlYXNbZF0ucmVtb3ZlRHJvcHBpbmdFbGVtZW50KCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5kcm9wX2FyZWFzID0gW107CiAgICAgICAgfSwKICAgICAgICBnZXREcm9wQXJlYXMoKXsKICAgICAgICAgICAgdGhpcy5pc0Ryb3BwYWJsZSA9IGZhbHNlOwogICAgICAgICAgICBpZih0aGlzLmRyb3BhcmVhcy5sZW5ndGg9PTApewogICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgdmFyIGFyZWFzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0aGlzLmRyb3BhcmVhcy5qb2luKCcsJykpOwogICAgICAgICAgIHZhciBtZSA9IHRoaXM7CiAgICAgICAgICAgW10uZm9yRWFjaC5jYWxsKGFyZWFzLGZ1bmN0aW9uKGVsKXsKICAgICAgICAgICAgICAgdmFyIGRyb3AgPSB7CiAgICAgICAgICAgICAgICAgICBlbDogZWwsCiAgICAgICAgICAgICAgICAgICBkaW06IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLAogICAgICAgICAgICAgICAgICAgYWN0aXZlOiBmYWxzZSwKICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOltdLAogICAgICAgICAgICAgICAgICAgZHJvcHBpbmdfZWxlbWVudF9pbmRleDotMSwKICAgICAgICAgICAgICAgICAgIGRyb3BwaW5nX2VsZW1lbnQ6bnVsbCwgLy9ob2xkcyBhIHJlZmVyZW5jZSB0byBkcm9wcGluZyBlbGVtZW50IGluIG9yZGVyIHRvIHJlbW92ZSBpdAogICAgICAgICAgICAgICAgICAgcmVtb3ZlRHJvcHBpbmdFbGVtZW50OmZ1bmN0aW9uKCl7CiAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5kcm9wcGluZ19lbGVtZW50IT1udWxsKXsKICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLmVsKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbC5yZW1vdmVDaGlsZCh0aGlzLmRyb3BwaW5nX2VsZW1lbnQpOwogICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3BwaW5nX2VsZW1lbnQgPSBudWxsOwogICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICBjcmVhdGVEcm9wcGluZ0VsZW1lbnQ6ZnVuY3Rpb24ocGFyYW1zKXsKICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3BwaW5nX2VsZW1lbnQgPSBtZS5kcm9wcGluZ19lbGVtZW50KCk7CiAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wcGluZ19lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3Z1ZS1kcm9wcGluZy1wbGFjZWhvbGRlcicpOwogICAgICAgICAgICAgICAgICAgICAgIGlmKCFtZS5zb3J0YWJsZSl7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQodGhpcy5kcm9wcGluZ19lbGVtZW50KTsKICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld19pbmRleCA9IHRoaXMuZmluZERyb3BwaW5nRWxlbWVudF9pbmRleChwYXJhbXMpCiAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzOwogICAgICAgICAgICAgICAgICAgICAgIHRoYXQuZHJvcHBpbmdfZWxlbWVudF9pbmRleCA9IG5ld19pbmRleDsKICAgICAgICAgICAgICAgICAgICAgICAgaWYobmV3X2luZGV4PT0tMSl7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdmaXJzdCcpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5lbC5hcHBlbmRDaGlsZCh0aGF0LmRyb3BwaW5nX2VsZW1lbnQpOwogICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZSAKICAgICAgICAgICAgICAgICAgICAgICAgaWYobmV3X2luZGV4PT10aGF0LmNoaWxkcmVuLmxlbmd0aCl7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdsYXN0Jyk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmVsLmFwcGVuZENoaWxkKHRoYXQuZHJvcHBpbmdfZWxlbWVudCk7CiAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNlewogICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnYmVmb3JlJykKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuZWwuaW5zZXJ0QmVmb3JlKHRoYXQuZHJvcHBpbmdfZWxlbWVudCx0aGF0LmNoaWxkcmVuW25ld19pbmRleF0pOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgZmluZERyb3BwaW5nRWxlbWVudF9pbmRleDpmdW5jdGlvbihwYXJhbXMpewogICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleD0wOwogICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3AgPSBwYXJhbXMudG9wOyAgICAKICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3X2luZGV4ID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBjaGlsZCBvZiB0aGlzLmVsLmNoaWxkcmVuKXsKICAgICAgICAgICAgICAgICAgICAgICAgICAgLy92YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2luZGV4XTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBsYWNlaG9sZGVyX2RpbSA9IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDowLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDowCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjaGlsZC5jbGFzc0xpc3QuY29udGFpbnMoJ3Z1ZS1kcm9wcGluZy1wbGFjZWhvbGRlcicpKXsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZm91bmRfcGxhY2Vob2xkZXIgPSB0cnVlOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJfZGltID0gY2hpbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcl9kaW0ud2lkdGg7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb250aW51ZTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2ZvdW5kJyxmb3VuZF9wbGFjZWhvbGRlciwgZm91bmRfcGxhY2Vob2xkZXJfYmVmb3JlKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAvL3ZhciBkaW0gPSBjaGlsZC5kaW07Ly9nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpbSA9IGNoaWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOwoKICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodG9wPmRpbS50b3ArKGRpbS5oZWlnaHQvMikpewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3X2luZGV4ID0gaW5kZXg7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4Kys7CiAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgIC8qKgogICAgICAgICAgICAgICAgICAgICAgIGlmKGZhbHNlICYmIGZvdW5kX3BsYWNlaG9sZGVyX2JlZm9yZSl7CiAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld19pbmRleCA9IHBhcnNlSW50KG5ld19pbmRleCk7CiAgICAgICAgICAgICAgICAgICAgICAgfWVsc2V7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICoqLwogICAgICAgICAgICAgICAgICAgICAgICBuZXdfaW5kZXg9cGFyc2VJbnQobmV3X2luZGV4KTsKICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld19pbmRleDsKICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICBzb3J0RHJvcHBpbmdFbGVtZW50OmZ1bmN0aW9uKHBhcmFtcyl7CiAgICAgICAgICAgICAgICAgICAgICAgLy92YXIgbGVmdCA9IHBhcmFtcy5sZWZ0OwogICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3AgPSBwYXJhbXMudG9wOyAgICAKICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3X2luZGV4ID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4PTA7CiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgY2hpbGQgb2YgdGhpcy5lbC5jaGlsZHJlbil7CiAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpbmRleF07CiAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwbGFjZWhvbGRlcl9kaW0gPSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6MCwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6MAogICAgICAgICAgICAgICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2hpbGQuY2xhc3NMaXN0LmNvbnRhaW5zKCd2dWUtZHJvcHBpbmctcGxhY2Vob2xkZXInKSl7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZvdW5kX3BsYWNlaG9sZGVyID0gdHJ1ZTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyX2RpbSA9IGNoaWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJfZGltLndpZHRoOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29udGludWU7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdmb3VuZCcsZm91bmRfcGxhY2Vob2xkZXIsIGZvdW5kX3BsYWNlaG9sZGVyX2JlZm9yZSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgLy92YXIgZGltID0gY2hpbGQuZGltOy8vZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaW0gPSBjaGlsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsKCiAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRvcD5kaW0udG9wKyhkaW0uaGVpZ2h0LzIpKXsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld19pbmRleCA9IGluZGV4OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCsrOwogICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAvKioKICAgICAgICAgICAgICAgICAgICAgICBpZihmYWxzZSAmJiBmb3VuZF9wbGFjZWhvbGRlcl9iZWZvcmUpewogICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdfaW5kZXggPSBwYXJzZUludChuZXdfaW5kZXgpOwogICAgICAgICAgICAgICAgICAgICAgIH1lbHNlewogICAgICAgICAgICAgICAgICAgICAgICAgICAqKi8KICAgICAgICAgICAgICAgICAgICAgICAgbmV3X2luZGV4PXBhcnNlSW50KG5ld19pbmRleCk7CiAgICAgICAgICAgICAgICAgICAgICAgLy99CiAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgaWYobmV3X2luZGV4IT10aGlzLmRyb3BwaW5nX2VsZW1lbnRfaW5kZXgpewogICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG1lLnNvcnREcm9wcGluZ0VsZW1lbnRfdGltZW91dCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZS5zb3J0RHJvcHBpbmdFbGVtZW50X3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhhdC5kcm9wcGluZ19lbGVtZW50PT1udWxsKXsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmRyb3BwaW5nX2VsZW1lbnRfaW5kZXggPSBuZXdfaW5kZXg7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYobmV3X2luZGV4PT0tMSl7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2ZpcnN0Jyk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuZWwuYXBwZW5kQ2hpbGQodGhhdC5kcm9wcGluZ19lbGVtZW50KTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZSAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihuZXdfaW5kZXg9PXRoYXQuY2hpbGRyZW4ubGVuZ3RoKXsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnbGFzdCcpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmVsLmFwcGVuZENoaWxkKHRoYXQuZHJvcHBpbmdfZWxlbWVudCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2V7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2JlZm9yZScpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuZWwuaW5zZXJ0QmVmb3JlKHRoYXQuZHJvcHBpbmdfZWxlbWVudCx0aGF0LmNoaWxkcmVuW25ld19pbmRleF0pOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sMTIpOwogICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgaWYobWUuc29ydGFibGUpewogICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ZXI9MDsKICAgICAgICAgICAgICAgICAgIGZvcih2YXIgY2hpbGQgb2YgZWwuY2hpbGRyZW4pewogICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmRpbSA9IGNoaWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOwogICAgICAgICAgICAgICAgICAgICAgIGlmKGNoaWxkIT09bWUuJGVsKXsKICAgICAgICAgICAgICAgICAgICAgICAgZHJvcC5jaGlsZHJlbi5wdXNoKGNoaWxkKTsvL3Nob3VsZCB3ZSBwdXNoIG91ciBzZWxmPwogICAgICAgICAgICAgICAgICAgICAgIH1lbHNlewogICAgICAgICAgICAgICAgICAgICAgICAgICBkcm9wLmRyb3BwaW5nX2VsZW1lbnRfaW5kZXggPSBjb3VudGVyOwogICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXIrKzsKICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICBtZS5kcm9wX2FyZWFzLnB1c2goZHJvcCk7CiAgICAgICAgICAgfSkKICAgICAgICAgICBpZih0aGlzLmRyb3BfYXJlYXMubGVuZ3RoPjApewogICAgICAgICAgICAgICB0aGlzLmlzRHJvcHBhYmxlID0gdHJ1ZTsKICAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICBjb250YWlucyhkcm9wcGFibGUsZHJhZ2dhYmxlKXsKICAgICAgICAgICAgdmFyIGRpbSA9IGRyb3BwYWJsZS5kaW07CiAgICAgICAgICAgCiAgICAgICAgICAgIGlmKGRpbS5sZWZ0PGRyYWdnYWJsZS5sZWZ0KyhkcmFnZ2FibGUud2lkdGgvMS41KSAmJiBkaW0ubGVmdCtkaW0ud2lkdGg+ZHJhZ2dhYmxlLmxlZnQrKGRyYWdnYWJsZS53aWR0aC8xLjUpIAogICAgICAgICAgICAmJiBkaW0udG9wPGRyYWdnYWJsZS50b3ArKGRyYWdnYWJsZS5oZWlnaHQvMS41KSAmJiBkaW0udG9wK2RpbS5oZWlnaHQ+ZHJhZ2dhYmxlLnRvcCsoZHJhZ2dhYmxlLmhlaWdodC8xLjUpKXsKICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgfQogICAgfSwKICAgIGNyZWF0ZWQoKXsKICAgICAgICBpZih0eXBlb2YgdGhpcy4kdmRyYWdnYWJsZT09J3VuZGVmaW5lZCcpewogICAgICAgICAgICBWdWUucHJvdG90eXBlLiR2ZHJhZ2dhYmxlID0gVnVlLm9ic2VydmFibGUoewogICAgICAgICAgICAgICAgY3JlYXRpb25zOjAsCiAgICAgICAgICAgICAgICBpbnN0YW5jZXM6MCwKICAgICAgICAgICAgICAgIGlzRHJhZ2dpbmc6ZmFsc2UsCiAgICAgICAgICAgICAgICBjdXJyZW50Om51bGwKICAgICAgICAgICAgfSkKICAgICAgICB9CiAgICAgICAgdGhpcy4kdmRyYWdnYWJsZS5jcmVhdGlvbnMrKzsKICAgICAgICB0aGlzLiR2ZHJhZ2dhYmxlLmluc3RhbmNlcysrOwogICAgfSwKICAgIGRlc3Ryb3koKXsKICAgICAgICB0aGlzLiR2ZHJhZ2dhYmxlLmluc3RhbmNlcy0tOwogICAgICAgIHRoaXMucmVtb3ZlRXZlbnRIYW5kbGVycygpOwogICAgfSwKICAgIG1vdW50ZWQoKXsKICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMuJHNsb3RzLmRlZmF1bHQpOwogICAgICAgIGlmKHR5cGVvZiB0aGlzLiRzbG90cy5kZWZhdWx0IT09J3VuZGVmaW5lZCcgJiYgdGhpcy4kc2xvdHMuZGVmYXVsdC5sZW5ndGg+MCl7CiAgICAgICAgICAgIC8vY29uc29sZS5sb2codGhpcy4kc2xvdHMuZGVmYXVsdCk7CiAgICAgICAgICAgIHRoaXMuZHNEb20gPSB0aGlzLiRlbDsvL3RoaXMuJHNsb3RzLmRlZmF1bHRbMF0uZWxtOwogICAgICAgIH0KICAgICAgICBpZih0aGlzLmRyYWdoYW5kbGUhPScnICYmIHRoaXMuZHNEb20hPW51bGwpewogICAgICAgICAgICB0aGlzLmRvbUhhbmRsZSA9IHRoaXMuZHNEb20ucXVlcnlTZWxlY3Rvcih0aGlzLmRyYWdoYW5kbGUpOwogICAgICAgIH0KICAgICAgICBpZih0aGlzLmRyb3BhcmVhcy5sZW5ndGg+MCl7CiAgICAgICAgICAgIHRoaXMuaXNEcm9wcGFibGUgPSB0cnVlOwogICAgICAgIH0KICAgICAgICAKICAgICAgICB0aGlzLmNvbnRhaW5tZW50RWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5jb250YWlubWVudCk7CiAgICAgICAgCiAgICAgICAgdGhpcy5jc3NQb3NpdGlvbiA9IHRoaXMuZHNEb20uc3R5bGUucG9zaXRpb247CgogICAgICAgIAogICAgICAgIHRoaXMuc2V0dXBFdmVudEhhbmRsZXJzKCk7CiAgICB9Cn0K"},{"version":3,"sources":["vue-draggable.vue"],"names":[],"mappings":";;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA","file":"vue-draggable.vue","sourceRoot":".","sourcesContent":["<template>\n    <component :is=\"tag\" :class=\"{'vue-draggable':true,'vue-dragging':is_dragging}\">\n        <slot></slot>\n    </component>\n</template>\n<script>\nimport Vue from 'vue';\nexport default{\n    name:'vue-draggable',\n    props:{\n        tag:{\n            required:false,\n            type:String,\n            default:'span',\n            validator:function(value){\n                return ['br','script','noscript','dfn','object']\n                .indexOf(value)==-1\n            }\n        },\n        zindex:{\n            required:false,\n            type:Number,\n            default:100 //what z-index to set while dragging\n        },\n        axis:{\n            required:false,\n            type:String,\n            default:'xy'\n        },\n        offset:{ //how many pixels to move to count it as dragging\n            required:false,\n            type:Number,\n            default:10\n        },\n        \n        draghandle:{\n            required:false,\n            type:String,\n            default:'' //a selector from the slot or the target\n        },\n        clone:{\n            required:false,\n            type:Boolean,\n            default:false\n        },\n        clone_element:{\n            required:false,\n            type:Function,\n            default:null\n        },\n        clone_opacity:{\n            required:false,\n            type:Number,\n            default:0.5\n        },\n        dropareas:{\n            required:false,\n            type:Array,\n            default:function(){\n                return [];\n            }\n        },\n        dropping_element:{\n            required:false,\n            type:Function,\n            default:function(){\n                var div = document.createElement('div');\n                div.style.cssText = 'height:20px;border:dashed 2px #afafaf';\n                div.classList.add('vue-dropping-ghost');\n                return div;\n            }\n        },\n        drop_ghost:{ //drag but after you drop, return to its first position\n            required:false,\n            type:Boolean,\n            default:false\n        },\n        containment:{\n            required:false,\n            type:String,\n            default:'body'\n        },\n        sortable:{\n            required:false,\n            type:Boolean,\n            default:false\n        }\n    },\n    data(){\n        return {\n            domElement:null, //which one to drag\n            dragElement:null,\n            cloneElement:null,\n            domHandle:null, //from where to drag\n            droppingElement:null,\n            containmentElement:null,\n            containmentRect:null,\n            original_target:null,\n            orginal_handle:null,\n            isDragging:false,\n            isDropping:false,\n            dragStartX:-1,\n            dragStartY:-1,\n            elementX:-1,\n            elemnentY:-1,\n            elementDiffX:0,\n            elementDiffY:0,\n            isDroppable:false, // if we have dropareas than it is a droppable\n            dropped_area:null,//the about to drop area\n            drop_areas:[],\n            cssPosition:'',\n            sortDroppingElement_timeout:0\n        }\n    },\n    computed:{\n        is_dragging(){\n            return this.isDragging;\n        },\n        is_dropping(){\n            return this.isDropping;\n        }\n    },\n    methods:{\n        dragStarted(event){\n            event.preventDefault();\n            \n\n            if( (event.which && event.which==3) || (event.button && event.button==2)){//should not detect right clicks as mousedown for dragging\n                return;\n            }\n\n            this.isDroppable = false;\n            this.dropped_area = null;\n\n            this.dragStartX = event.touches && event.touches.length>0?event.touches[0].pageX:event.pageX;\n            this.dragStartY = event.touches && event.touches.length>0?event.touches[0].pageY:event.pageY;\n            this.$vdraggable.current = this;\n\n            var dim = this.dsDom.getBoundingClientRect();\n            this.elementX = dim.left;\n            this.elementY = dim.top;\n            this.elementDiffX = event.pageX - dim.left;\n            this.elementDiffY = event.pageY - dim.top;\n\n            this.containmentRect = this.containmentElement.getBoundingClientRect();\n\n            document.addEventListener('mousemove',this.dragMove);\n            document.addEventListener('touchmove',this.dragMove);\n            document.addEventListener('mouseup',this.dragEnd);\n            document.addEventListener('touchend',this.dragEnd);\n        },\n        dragMove(event){\n            event.preventDefault();\n\n            this.dropped_area = null;\n            \n            var pageX = event.touches && event.touches.length>0?event.touches[0].pageX:event.pageX;\n            var pageY = event.touches && event.touches.length>0?event.touches[0].pageY:event.pageY;\n            var diffX = pageX - this.dragStartX;\n            var diffY = pageY - this.dragStartY;\n            if(this.axis=='xy' && (Math.abs(diffX)>this.offset || Math.abs(diffY)>this.offset ) ){\n                this.isDragging = true;\n            }else if(this.axis=='x' && Math.abs(diffX)>this.offset){\n                this.isDragging = true;\n            }else if(this.axis=='y' && Math.abs(diffY)>this.offset){\n                this.isDragging = true;\n            }\n            if(this.isDragging){\n                if(this.dragElement==null){\n                    //first time we enter here when isDragging became true for first time\n                    \n                    this.getDropAreas();\n                }\n                if(this.clone && this.dragElement==null){\n                    if(this.clone_element!=null){\n                        this.dragElement = this.clone_element({instance:this,el: this.dsDom});\n                    }else{\n                        var dim = this.dsDom.getBoundingClientRect();\n                        this.dragElement = this.dsDom.cloneNode(true);\n                        this.dragElement.style.opacity = this.clone_opacity;\n                        this.dragElement.style.position='absolute';\n                        this.dragElement.style.left = dim.left+'px';\n                        this.dragElement.style.top = dim.top+'px';\n                    }\n                    document.body.appendChild(this.dragElement);\n\n                    this.$emit('drag_started',{instance:this,dragElement: this.dragElement, clone: this.clone})\n                }else if(this.dragElement==null){\n                    this.dragElement = this.dsDom;\n                    this.$emit('drag_started',{instance:this,dragElement: this.dragElement, clone:this.clone})\n                }\n                this.dragElement.style.position='absolute';\n\n                var finalX = pageX - this.elementDiffX;\n                var finalY = pageY - this.elementDiffY;\n\n                //check the containment, if we are inside the bounds of permitted dragging area\n                if(finalX<this.containmentRect.left || finalX+this.dragElement.offsetWidth>this.containmentRect.left+this.containmentRect.width\n            || finalY<this.containmentRect.top || finalY+this.dragElement.offsetHeight>this.containmentRect.top+this.containmentRect.height){\n                return;//do not drag outside containment\n            }\n\n\n                \n                if(this.axis=='xy' || this.axis=='x'){\n                    this.dragElement.style.left = finalX+'px';\n                }\n                if(this.axis=='xy' || this.axis=='y'){\n                    this.dragElement.style.top = finalY+'px';\n                }\n\n                this.$emit('dragging',{instance:this, dragElement: this.dragElement, clone: this.clone, coords:{x:finalX,y:finalY},nativeEvent: event})\n\n                if(this.isDroppable){\n                    //find in which droppable we are contained\n                    //var is_contained = false;\n                    for(var d=0;d<this.drop_areas.length;d++){\n                        var drop_area = this.drop_areas[d];\n                        \n                        var draggable = {\n                            left: finalX,\n                            top: finalY,\n                            width: this.dragElement.offsetWidth,\n                            height: this.dragElement.offsetHeight\n                        };\n                        \n                        if(this.contains(drop_area,draggable)){ \n                            \n                            //is_contained = true;\n                            drop_area.el.classList.add('vue-dropping');\n                            this.dropped_area = drop_area;\n                            //if we have not marked as active drop area, mark it (so we do not send none stop drop enter event)\n                            //also we do not need to recreate the ghost dropping_element again and again, one time is enought\n                            if(!drop_area.active){\n                                drop_area.active = true;\n                                drop_area.createDroppingElement({\n                                    left: finalX,\n                                    top: finalY\n                                });\n                                if(this.sortable){\n                                    //get all first depth children of drop_area\n                                    drop_area.sortDroppingElement({\n                                        left: finalX,\n                                        top: finalY\n                                    });\n                                }\n                                this.$emit('drop_enter',{instance:this, dragElement:this.dragElement,clone:this.clone,areaElement: drop_area.el});    \n                                this.drop_areas[d] = drop_area;\n                            }else{\n                                drop_area.sortDroppingElement(\n                                    {\n                                        left: finalX,\n                                        top: finalY\n                                    }\n                                );\n                                this.$emit('dropping',{instance:this, dragElement:this.dragElement, clone:this.clone, areaElement: drop_area.el});\n                            }\n                        }else{\n                            //is_contained = false;\n                            /**\n                            if(drop_area.active){\n                                if(drop_area.dropping_element!=null){\n                                    drop_area.el.removeChild(drop_area.dropping_element);\n                                    drop_area.dropping_element = null;\n                                }\n                                this.$emit('drop_exit',{instance:this, dragElement:this.dragElement, clone:this.clone, areaElement: drop_area.el});\n                                drop_area.active= false;\n                                this.drop_areas[d] = drop_area;\n                            }\n                            drop_area.el.classList.remove('vue-dropping')\n                            **/\n                        }\n\n                    }//for\n                    \n                    //loop through all the drop_areas and any drop_area that is not currently active\n                    //remove its active state and remove also any ghost dropping element\n                    for(var dd=0;dd<this.drop_areas.length;dd++){\n                        if(this.drop_areas[dd]!=this.dropped_area && this.drop_areas[dd].active){\n                            this.drop_areas[dd].el.classList.remove('vue-dropping');\n                            this.drop_areas[dd].active = false;\n                            this.drop_areas[dd].removeDroppingElement();\n                        }\n                    }\n                    \n\n                }//if(this.isDroppable)\n                \n            }//if(this.isDragging)\n        },\n        dragEnd(event){\n            event.preventDefault();\n            \n            /** CHECK IF WE WERE DRAGGING vis isDragging, because might never started */\n            //console.log(event);\n            if(this.isDragging){\n            var drag_element = this.dragElement;\n            if(this.clone && this.isDragging){ //be sure to remove clone element if we indeed dragged\n                document.body.removeChild(this.dragElement);\n                \n            }\n\n            \n            this.dragElement = null;\n            this.dsDom.style.position = 'absolute';\n\n            var pageX = event.touches && event.touches.length>0?event.touches[0].pageX:event.pageX;\n            var pageY = event.touches && event.touches.length>0?event.touches[0].pageY:event.pageY;\n\n            if(this.axis=='xy' || this.axis=='x'){\n                this.dsDom.style.left = pageX - this.elementDiffX+'px';\n            }\n            if(this.axis=='xy' || this.axis=='y'){\n                this.dsDom.style.top = pageY - this.elementDiffY+'px';\n            }\n            if(this.isDroppable && this.dropped_area!=null){\n                var index = -1;\n                if(this.sortable){\n                    index = this.dropped_area.dropping_element_index;\n                }\n                this.$emit('dropped',{instance:this,areaElement:this.dropped_area.el,dragElement:drag_element,clone:this.clone,sortable: this.sortable, newIndex: index })\n                \n                //this.dropped_area.el.classList.remove('vue-dropping');\n\n                //remove the dropping_element\n                //this.dropped_area.el.removeChild(this.dropped_area.dropping_element);\n                //if we are acting as a ghost then do not append the element in the droppable area and return it\n                //to its previous position, we are responsible to create the element we want in the dropped area\n                if(!this.drop_ghost){\n                   // alert('done');\n                    if(this.sortable){\n                        var dropping_index = this.dropped_area.dropping_element_index;\n                        if(dropping_index>=0 && dropping_index<=this.dropped_area.children.length){\n                            this.dropped_area.el.insertBefore(this.dsDom, this.dropped_area.children[dropping_index])\n                        }else{\n                            this.dropped_area.el.appendChild(this.dsDom);\n                        }\n                    }else{\n                        this.dropped_area.el.appendChild(this.dsDom);\n                    }\n                    this.dsDom.style.position = this.cssPosition;\n                }else if(this.drop_ghost){\n                    this.dsDom.style.position = this.cssPosition;\n                }\n            }else if(this.isDroppable){\n                //return to previous position\n                this.dsDom.style.position = this.cssPosition;\n            }\n            }\n            this.isDragging = false;\n            this.isDroppable = false;\n            //this.isDragging = false;\n            this.dropped_area = null;\n            this.$emit('drag_ended',{instance:this});\n            this.resetDropAreas();\n            document.removeEventListener('mousemove',this.dragMove);\n            document.removeEventListener('mouseup',this.dragEnd);\n        },\n        setupEventHandlers(){\n            this.dsDom.addEventListener('mousedown',this.dragStarted)\n            this.dsDom.addEventListener('touchstart',this.dragStarted);\n            this.dsDom.addEventListener('dragstart',(event)=>{\n                event.preventDefault();\n            } )\n        },\n        getId(){\n            var d = new Date();\n            return 'vdraggable-'+d.getMilliseonds();\n        },\n        resetDropAreas(){\n            \n            for(var d=0;d<this.drop_areas.length;d++){\n                this.drop_areas[d].el.classList.remove('vue-dropping');\n                this.drop_areas[d].active = false;\n                //ean exo dropping element dimiourgimeno, katestrepse to\n                if(this.drop_areas[d].dropping_element!=null){\n                    this.drop_areas[d].removeDroppingElement();\n                }\n            }\n            this.drop_areas = [];\n        },\n        getDropAreas(){\n            this.isDroppable = false;\n            if(this.dropareas.length==0){\n                return;\n            }\n           var areas = document.querySelectorAll(this.dropareas.join(','));\n           var me = this;\n           [].forEach.call(areas,function(el){\n               var drop = {\n                   el: el,\n                   dim: el.getBoundingClientRect(),\n                   active: false,\n                   children:[],\n                   dropping_element_index:-1,\n                   dropping_element:null, //holds a reference to dropping element in order to remove it\n                   removeDroppingElement:function(){\n                       if(this.dropping_element!=null){\n                           //console.log(this.el);\n                           this.el.removeChild(this.dropping_element);\n                           this.dropping_element = null;\n                       }\n                   },\n                   createDroppingElement:function(params){\n                       this.dropping_element = me.dropping_element();\n                       this.dropping_element.classList.add('vue-dropping-placeholder');\n                       if(!me.sortable){\n                        this.el.appendChild(this.dropping_element);\n                       }\n                       var new_index = this.findDroppingElement_index(params)\n                       var that = this;\n                       that.dropping_element_index = new_index;\n                        if(new_index==-1){\n                            //console.log('first');\n                            that.el.appendChild(that.dropping_element);\n                        }else \n                        if(new_index==that.children.length){\n                            //console.log('last');\n                            that.el.appendChild(that.dropping_element);\n                        }else{\n                            //console.log('before')\n                            that.el.insertBefore(that.dropping_element,that.children[new_index]);\n                        }\n                   },\n                   findDroppingElement_index:function(params){\n                       var index=0;\n                       var top = params.top;    \n                       var new_index = 0;\n                        for(var child of this.el.children){\n                           //var child = this.children[index];\n                           var placeholder_dim = {\n                                width:0,\n                                height:0\n                            };\n                           if(child.classList.contains('vue-dropping-placeholder')){\n                               //found_placeholder = true;\n                               placeholder_dim = child.getBoundingClientRect();\n                               placeholder_dim.width;\n                                //continue;\n                               //console.log('found',found_placeholder, found_placeholder_before);\n                           }\n                           //var dim = child.dim;//getBoundingClientRect();\n                           var dim = child.getBoundingClientRect();\n\n                           \n                                if(top>dim.top+(dim.height/2)){\n                                    \n                                    new_index = index;\n                                }\n                            \n                           index++;\n                       }\n                       /**\n                       if(false && found_placeholder_before){\n                           new_index = parseInt(new_index);\n                       }else{\n                           **/\n                        new_index=parseInt(new_index);\n                        return new_index;\n                   },\n                   sortDroppingElement:function(params){\n                       //var left = params.left;\n                       var top = params.top;    \n                       var new_index = 0;\n                       \n                        var index=0;\n                        for(var child of this.el.children){\n                           //var child = this.children[index];\n                           var placeholder_dim = {\n                                width:0,\n                                height:0\n                            };\n                           if(child.classList.contains('vue-dropping-placeholder')){\n                               //found_placeholder = true;\n                               placeholder_dim = child.getBoundingClientRect();\n                               placeholder_dim.width;\n                                //continue;\n                               //console.log('found',found_placeholder, found_placeholder_before);\n                           }\n                           //var dim = child.dim;//getBoundingClientRect();\n                           var dim = child.getBoundingClientRect();\n\n                           \n                                if(top>dim.top+(dim.height/2)){\n                                    \n                                    new_index = index;\n                                }\n                            \n                           index++;\n                       }\n                       /**\n                       if(false && found_placeholder_before){\n                           new_index = parseInt(new_index);\n                       }else{\n                           **/\n                        new_index=parseInt(new_index);\n                       //}\n                       \n                       if(new_index!=this.dropping_element_index){\n                            clearTimeout(me.sortDroppingElement_timeout);\n                            var that = this;\n                            me.sortDroppingElement_timeout = setTimeout(function(){\n                                if(that.dropping_element==null){\n                                    return;\n                                }\n                                that.dropping_element_index = new_index;\n                                if(new_index==-1){\n                                    //console.log('first');\n                                    that.el.appendChild(that.dropping_element);\n                                }else \n                                if(new_index==that.children.length){\n                                    //console.log('last');\n                                    that.el.appendChild(that.dropping_element);\n                                }else{\n                                    //console.log('before')\n                                    that.el.insertBefore(that.dropping_element,that.children[new_index]);\n                                }\n                            },12);\n                       }\n                   }\n               };\n               if(me.sortable){\n                   var counter=0;\n                   for(var child of el.children){\n                       \n                       child.dim = child.getBoundingClientRect();\n                       if(child!==me.$el){\n                        drop.children.push(child);//should we push our self?\n                       }else{\n                           drop.dropping_element_index = counter;\n                       }\n                       \n                      counter++;\n                   }\n               }\n               me.drop_areas.push(drop);\n           })\n           if(this.drop_areas.length>0){\n               this.isDroppable = true;\n           }\n        },\n        contains(droppable,draggable){\n            var dim = droppable.dim;\n           \n            if(dim.left<draggable.left+(draggable.width/1.5) && dim.left+dim.width>draggable.left+(draggable.width/1.5) \n            && dim.top<draggable.top+(draggable.height/1.5) && dim.top+dim.height>draggable.top+(draggable.height/1.5)){\n                return true;\n            }\n            \n            return false;\n        }\n    },\n    created(){\n        if(typeof this.$vdraggable=='undefined'){\n            Vue.prototype.$vdraggable = Vue.observable({\n                creations:0,\n                instances:0,\n                isDragging:false,\n                current:null\n            })\n        }\n        this.$vdraggable.creations++;\n        this.$vdraggable.instances++;\n    },\n    destroy(){\n        this.$vdraggable.instances--;\n        this.removeEventHandlers();\n    },\n    mounted(){\n        //console.log(this.$slots.default);\n        if(typeof this.$slots.default!=='undefined' && this.$slots.default.length>0){\n            //console.log(this.$slots.default);\n            this.dsDom = this.$el;//this.$slots.default[0].elm;\n        }\n        if(this.draghandle!='' && this.dsDom!=null){\n            this.domHandle = this.dsDom.querySelector(this.draghandle);\n        }\n        if(this.dropareas.length>0){\n            this.isDroppable = true;\n        }\n        \n        this.containmentElement = document.querySelector(this.containment);\n        \n        this.cssPosition = this.dsDom.style.position;\n\n        \n        this.setupEventHandlers();\n    }\n}\n</script>"]}]}